import I18n from './I18n.js';
import Locale from './Locale.js';
import $t from './getters/$t.js';
export default class I18nLite {
    constructor(options) {
        this.default_locale_id = options?.default_locale_id;
        this.formatters = options?.formatters ?? {};
        this.getters = {
            $t,
            ...options?.getters,
        };
        this.locales = new Map();
        this.nested_limit = options?.nested_limit ?? 3;
    }
    createTranslator(locale_id) {
        const i18n = this;
        function t(key, args) {
            return i18n.t(locale_id, key, args);
        }
        t.locale = this.locales.get(locale_id);
        return t;
    }
    loadParsed(locale_id, messages) {
        const locale = new Locale(this, locale_id, messages);
        this.locales.set(locale_id, locale);
        return locale;
    }
    resolve(obj, key) {
        return key
            .split(/\./g)
            .reduce((acc, part) => acc && acc[part], obj);
    }
    t(locale_id, key, args = {}, nested = 0) {
        if (nested > this.nested_limit) {
            throw new Error(`Potential circular translation, "${key}" exceeded nesting limit (${this.nested_limit})`);
        }
        if (!this.locales.has(locale_id)) {
            throw new Error(`A locale with the name of "${locale_id}" does not exist`);
        }
        const locale = this.locales.get(locale_id);
        if (!locale.has(key)) {
            throw new Error(`The "${locale_id}" locale does not contain a message with the key "${key}"`);
        }
        let message = locale.get(key);
        if ('q' in message) {
            const plural_type = (message.q.cardinal && 'cardinal') || (message.q.ordinal && 'ordinal') || null;
            if (plural_type) {
                const input = this.resolve(args, message.q[plural_type]);
                if (isNaN(Number(input)) && !Array.isArray(input)) {
                    throw new Error(`A number/array value for the "${message.q[plural_type]}" variable is required`);
                }
                const literal = `${key}.=${input}`;
                if (locale.has(literal)) {
                    key = literal;
                }
                else {
                    const pr = new Intl.PluralRules(locale_id, { type: plural_type });
                    const rule = Array.isArray(input) ? pr.selectRange(...input) : pr.select(input);
                    key = key + '.' + rule;
                    if (!locale.has(key)) {
                        throw new Error(`Pluralisation failed: the "${locale_id}" locale does not contain a message with the key "${key}"`);
                    }
                }
                message = locale.get(key);
            }
        }
        let extracted;
        if (!('t' in message)) {
            if (!(this instanceof I18n) || !('o' in message)) {
                throw new Error(`Message "${key}" in the "${locale_id}" locale has not been extracted`);
            }
            const parsed = this.extract(message.o);
            locale.set(key, parsed);
            extracted = parsed;
        }
        else {
            extracted = message;
        }
        let offset = 0;
        let filled = extracted.t;
        if (extracted.p === undefined)
            return filled;
        for (const [position, placeholder] of extracted.p) {
            const corrected = position + offset;
            let value;
            let name;
            if ('v' in placeholder) {
                name = placeholder.v;
                const resolved = this.resolve(args, String(placeholder.v));
                if (typeof resolved === 'function') {
                    value = resolved(locale.formatters).result;
                }
                else {
                    value = resolved?.toString();
                }
            }
            else {
                name = placeholder.g;
                value = this.getters[placeholder.g].get(locale, [locale_id, key, args, nested], placeholder.d);
            }
            if (value === undefined)
                throw new Error(`A value for the "${name}" placeholder is required`);
            filled = filled.slice(0, corrected) + value + filled.slice(corrected);
            offset += value.length;
        }
        return filled;
    }
}
